<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Coerced Potato</title>
<link rel="stylesheet" href="/assets/css/styles.css">
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-KK94CHFLLe+nY2dmCWGMq91rCGa5gtU4mk92HdvYe+M/SXH301p5ILy+dN9+nJOZ" crossorigin="anonymous">

    <link rel="stylesheet" type="text/css" href="/assets/css/monokai.css">
  </head>
  <body data-bs-theme="dark">
    <header class="d-flex py-3 mb-4 border-bottom" style="align-items: center; justify-content: space-around;">
    <a href="/" class="d-flex align-items-center text-dark text-decoration-none">
      <span class="fs-4"><span class="logo1">Hack</span><span class="logo2">vens</span></span>
    </a>
    <button id="btnSwitch" class="">ğŸ’¡/ğŸŒ™</button>
    <script defer="defer">
      document.getElementById('btnSwitch').addEventListener('click',()=>{
      if (document.body.getAttribute('data-bs-theme') == 'dark') {
          document.body.setAttribute('data-bs-theme','light')
          document.documentElement.style.setProperty("--logo-color1", "#161616")
      }
      else {
          document.body.setAttribute('data-bs-theme','dark')
          document.documentElement.style.setProperty("--logo-color1", "#fff")

      }
      })
    </script>
  </header>
    <div class="container">
     <div class="post">
    <div class="post__back">
    	<a href="/">&lt;-- home</a>
    </div>
    <div class="post__title">
    	<h1>Articles / Coerced Potato</h1>
	<i>October 9, 2023</i>
    </div>
    <div class="post__meta">
    	<p></p>
    </div>
    <div class="post__content"?>
        <p><strong>CoercedPotato - Une patate de plus ! ğŸ¥”</strong></p>

<h1 id="table-des-matiÃ¨res">Table des matiÃ¨res</h1>

<p><a href="#introduction"><strong>1. Introduction</strong></a></p>

<p><a href="#une-histoire-de-privilÃ¨ges"><strong>2.</strong> <strong>Une histoire de privilÃ¨ges</strong></a></p>

<p><a href="#les-access-token-windows"><strong>3.</strong> <strong>Les AccessÂ TokenÂ Windows</strong></a></p>

<p><a href="#parlons-bien-parlons-named-pipe"><strong>4.</strong> <strong>Parlons bien, parlons Â«Â Named PipeÂ Â»</strong></a></p>

<p><a href="#un-peu-de-coercition-dauthentification"><strong>5.</strong> <strong>Un peu de Coercition dâ€™authentification</strong></a></p>

<p><a href="#un-peu-de-code-maintenant-c-on-fire"><strong>6.</strong> <strong>Un peu de code maintenant (C++ on fire)Â !</strong></a></p>

<p><a href="#remerciements"><strong>7.</strong> <strong>Remerciements</strong></a></p>

<h1 id="introduction"><strong>Introduction</strong></h1>

<p>Depuis 2016, de nombreux exploits nommÃ©sÂ Â«Â PotatoesÂ Â» ont Ã©tÃ© dÃ©couverts
et sont utilisÃ©s dans le but dâ€™Ã©lever ses privilÃ¨ges dans un systÃ¨me
dâ€™exploitation Windows. Le principe est toujours le mÃªmeÂ : passer dâ€™un
compte ayant les privilÃ¨ges adÃ©quats, souvent un compte de service, Ã 
<strong>NT AUTHORITY/SYSTEM</strong> (le compte le plus privilÃ©giÃ© sous
Windows)<strong><em>.</em></strong></p>

<p>Lâ€™objectif de cet article nâ€™est pas de passer en revue la collection
Â«Â PotatoesÂ Â» disponible Ã  ce jour. Pour cela, lâ€™excellent article de
@Blackwasp est disponible Ã  lâ€™URL suivant :
<a href="https://hideandsec.sh/books/windows-sNL/page/in-the-potato-family-i-want-them-all.">https://hideandsec.sh/books/windows-sNL/page/in-the-potato-family-i-want-them-all.</a></p>

<p>En revanche, la combinaison de plusieurs concepts connus a permis la
crÃ©ation dâ€™un nouvel outil : Â«Â <strong>CoercedPotato</strong>Â Â». Cet outil permet
notamment dâ€™Ã©lever ses privilÃ¨ges sur les versions les plus rÃ©centes de
â€œWindows 10â€ et â€œWindows Server 2022â€, Ã  date de lâ€™article.</p>

<p><img src="/assets/img/articles/coercedpotato/image1.png" style="width:6.3in;height:5.26389in; display:block; margin-left:auto; margin-right:auto" alt="Une image contenant texte, capture dâ€™Ã©cran, Police Description gÃ©nÃ©rÃ©e automatiquement" /></p>

<p>Notez que nous parlons de Â«Â nouvel outilÂ Â» et non pas Â«Â nouvelle
techniqueÂ Â», dans la mesure oÃ¹ celui-ci concatÃ¨ne les connaissances
actuelles concernant les <strong>impersonateÂ token</strong> et les mÃ©thodes
permettant de forcer des authentifications via des <strong>fonctions RPC
vulnÃ©rables</strong>. Ces deux concepts seront expliquÃ©s au fur et Ã  mesure de
lâ€™article.</p>

<p>Mais avant de commencer, il va falloir passer en revue plusieurs
fondamentaux.</p>

<h1 id="une-histoire-de-privilÃ¨ges"><strong>Une histoire de privilÃ¨ges</strong></h1>

<p>Â«Â If you have SeAssignPrimaryToken or SeImpersonatePrivilege, you are
SYSTEM Â». Câ€™est une citation issue dâ€™un tweet (un X ?) de <em>@decoder_it</em>
qui nâ€™est en somme pas trÃ¨s loin de la rÃ©alitÃ©.</p>

<p>Lors dâ€™un test dâ€™intrusion, et plus particuliÃ¨rement en test dâ€™intrusion
interne, nous parvenons frÃ©quemment Ã  exÃ©cuter du code Ã  distance. Dans
le cas dâ€™un systÃ¨me Windows, une fois une invite de commande obtenue sur
la machine ciblÃ©e, nous nous retrouvons parfois dans la situation
suivanteÂ : nous exÃ©cutons des commandes dans le contexte de sÃ©curitÃ© de
lâ€™utilisateur <strong>NT AUTHORITY\LOCAL SERVICE</strong>.</p>

<p><img src="/assets/img/articles/coercedpotato/image2.png" style="width:3.88203in;height:0.98002in; display:block; margin-left:auto; margin-right:auto" alt="Une image contenant texte, capture dâ€™Ã©cran, Police, ligne Description gÃ©nÃ©rÃ©e automatiquement" /></p>

<p>Ce compte dispose de privilÃ¨ges restreints sur le systÃ¨me. Lâ€™objectif
est donc dâ€™Ã©lever nos privilÃ¨ges et dâ€™obtenir une invite de commandes
dans le contexte de lâ€™utilisateur <strong>NT AUTHORITY\SYSTEM</strong>, afin de
prendre le contrÃ´le complet du systÃ¨me. Cela peut ensuite permettre de
tenter de rebondir sur dâ€™autres machines du rÃ©seau, en rÃ©cupÃ©rant des
identifiants en mÃ©moires vives, en interagissant avec les <em>access
tokens</em> de Windows, en rÃ©cupÃ©rant la base des utilisateurs
locaux, etc. Maisâ€¦ on sâ€™Ã©gareÂ !Â ğŸ˜Š</p>

<p>Pour revenir au sujet initial, lorsque nous listons les privilÃ¨ges de
lâ€™utilisateur <strong>NT AUTHORITY\LOCAL SERVICE</strong>, celui-ci dispose
normalement du privilÃ¨ge <strong>SeImpersonatePrivilege</strong>Â :</p>

<p><img src="/assets/img/articles/coercedpotato/image3.png" style="width:6.3in;height:1.77431in; display:block; margin-left:auto; margin-right:auto" alt="Une image contenant texte, capture dâ€™Ã©cran, Police Description gÃ©nÃ©rÃ©e automatiquement" /></p>

<p>Câ€™est ce privilÃ¨ge qui nous intÃ©resse tout particuliÃ¨rement pour la
suite de lâ€™articleÂ !</p>

<p>Si nous suivons la documentation officielle de Microsoft, ce privilÃ¨ge
permet <strong>Â«Â <em>lâ€™emprunt dâ€™identitÃ© dâ€™un client aprÃ¨s lâ€™authentification</em></strong>
<em>et la crÃ©ation de droits dâ€™utilisateur <strong>dâ€™objets globaux.</strong></em>Â Â»</p>

<p><em><a href="https://learn.microsoft.com/fr-fr/troubleshoot/windows-server/windows-security/seimpersonateprivilege-secreateglobalprivilege">https://learn.microsoft.com/fr-fr/troubleshoot/windows-server/windows-security/seimpersonateprivilege-secreateglobalprivilege</a></em></p>

<p>ConcrÃ¨tement, dans un environnement Windows, lorsquâ€™un utilisateur
possÃ¨de le privilÃ¨ge <strong>SeImpersonatePrivilege</strong>, il a la possibilitÃ© de
dÃ©marrer des processus (câ€™est-Ã -dire des programmes, par exemple
<strong>cmd.exe</strong>) au nom dâ€™un autre utilisateur. Cela se fait en appelant la
fonction <strong>CreateProcessWithTokenW()</strong> dans le contexte de sÃ©curitÃ© de
lâ€™utilisateur.</p>

<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithtokenw"><em>https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithtokenw</em></a></p>

<p>A noter quâ€™il existe un privilÃ¨ge trÃ¨s similaire Ã 
<strong>SeImpersonatePrivilegeÂ </strong>: <strong>SeAssignPrimaryToken</strong>. Il permet
Ã©galement le dÃ©marrage dâ€™un processus au nom dâ€™un autre utilisateur avec
la fonction <strong>CreateProcessAsUser()</strong>, mais nous ne rentrerons pas dans
les dÃ©tails dans cet article.</p>

<p><em><a href="https://learn.microsoft.com/fr-fr/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasuserw">https://learn.microsoft.com/fr-fr/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasuserw</a></em></p>

<p>Toutes les techniques dites Â«Â <strong>Potatoes</strong>Â Â» reposent sur ces privilÃ¨ges
(Ã  lâ€™exception de RemotePotato) pour obtenir des droits <strong>NT
AUTHORITY\SYSTEM</strong> (nous appellerons Ã§a les droits <strong>SYSTEM</strong> pour le
reste de lâ€™article) sur une machine Windows afin de la compromettre.
Vous lâ€™aurez compris, <strong>SeAssignPrimaryToken</strong> et
<strong>SeImpersonatePrivilege</strong> sont des privilÃ¨ges trÃ¨s prÃ©cieux pour un
attaquant et offrent (quasi) toujours la possibilitÃ© dâ€™Ã©lever ses
privilÃ¨ges.</p>

<p>Lâ€™objectif de lâ€™article est donc de montrer une nouvelle technique
exploitant ces privilÃ¨ges. Il est maintenant temps de rentrer dans le
vif du sujetÂ !Â </p>

<h1 id="les-accesstokenwindows"><strong>Les AccessÂ TokenÂ Windows</strong></h1>

<p>En parcourant la documentation de Microsoft, il est possible de
retrouver la dÃ©finition des fonctions Ã©noncÃ©es plus tÃ´tÂ :
<strong>CreateProcessWithTokenW</strong> et <strong>CreateProcessAsUserW</strong>. La structure de
ces fonctions est la suivanteÂ :</p>

<p><img src="/assets/img/articles/coercedpotato/image4.png" style="width:3.11927in;height:2.16522in;display:block; margin-left:auto; margin-right:auto" alt="Une image contenant texte, capture dâ€™Ã©cran, nombre, Police Description gÃ©nÃ©rÃ©e automatiquement" /><img src="/assets/img/articles/coercedpotato/image5.png" style="width:2.90177in;height:2.13404in;display:block; margin-left:auto; margin-right:auto" alt="Une image contenant texte, capture dâ€™Ã©cran, Police, nombre Description gÃ©nÃ©rÃ©e automatiquement" /></p>

<p>Il est intÃ©ressant de noter que ces deux fonctions nÃ©cessitent un
<strong>access token</strong> en argument pour Ãªtre utilisÃ©es, et plus spÃ©cifiquement
un <strong>primary token</strong>. Mais quâ€™est-ce que câ€™estÂ cette histoire de
<strong>token</strong> ?</p>

<p>Pour reprendre sa dÃ©finition telle que dÃ©crite par Microsoft, les
<em><strong>access token</strong> sont Â«Â des objets qui dÃ©crivent le contexte de
sÃ©curitÃ© dâ€™un processus ou dâ€™un thread.</em>Â Â».</p>

<p>ConcrÃ¨tement, lâ€™<strong>access token</strong>, ou jeton dâ€™accÃ¨s, est obtenu aprÃ¨s une
authentification rÃ©ussie et contient un ensemble dâ€™informations
essentielles pour Windows, tel que lâ€™identitÃ© de lâ€™utilisateur, son
groupe, sa liste de contrÃ´le dâ€™accÃ¨s (ACL), ses privilÃ¨ges et surtout,
le type de token. Il pourrait par exemple Ãªtre comparÃ© Ã  un jeton JWT
utilisÃ© par une application web.</p>

<p>Par exemple, si je dÃ©marre le processus <strong>cmd.exe</strong> avec un <strong>access
token</strong> appartenant Ã  lâ€™utilisateur <strong>vagrant</strong>, <strong>cmd.exe</strong> aura les
privilÃ¨ges du compte <strong>vagrant</strong>.</p>

<p><a href="https://learn.microsoft.com/fr-fr/windows/win32/secauthz/access-tokens">https://learn.microsoft.com/fr-fr/windows/win32/secauthz/access-tokens</a></p>

<p>Il existe deux types dâ€™<strong>access token</strong>Â : les <strong>primary token</strong> et les
<strong>impersonation token</strong>. Pour comprendre la diffÃ©rence entre ces deux
types de jetons, il est nÃ©cessaire de connaÃ®tre la diffÃ©rence entre un
thread et un processus dans un systÃ¨me Windows.</p>

<p>Pour faire simple, un processus est un espace mÃ©moire virtuel exÃ©cutant
du code sur le systÃ¨me. Un thread correspond Ã  du code exÃ©cutÃ© depuis un
processus. Il est donc temporaire et est dÃ©truit une fois terminÃ©.</p>

<p>Pour imager, lorsque lâ€™application Word est utilisÃ©e, le processus
<strong>WINWORD.exe</strong> est lancÃ© sur la machine. Ce processus est dÃ©marrÃ© par
lâ€™utilisateur avec son <strong>primary token</strong>. Lâ€™application va ensuite
utiliser des threads, par exemple pour gÃ©rer des tÃ¢ches en arriÃ¨re-plan
(affichage de lâ€™interface graphique, traitement des entrÃ©es utilisateur,
etc.). Cela permet une expÃ©rience fluide lors de lâ€™utilisation de Word.
Ces threads seront exÃ©cutÃ©s Ã  lâ€™aide dâ€™un <strong>impersonation token</strong>.</p>

<p><a href="https://learn.microsoft.com/fr-fr/windows/win32/com/processes--threads--and-apartments">https://learn.microsoft.com/fr-fr/windows/win32/com/processes--threads--and-apartments</a></p>

<p>Maintenant que les bases sont acquises, revenons Ã  nos moutons.</p>

<p>Comme expliquÃ© prÃ©cÃ©demment, pour pouvoir dÃ©marrer un processus dans le
contexte dâ€™un utilisateur, il nous faut deux chosesÂ : le privilÃ¨ge
adÃ©quat (<strong>SeImpersonatePrivilege</strong> ou <strong>SeAssignPrimaryToken</strong>) et un
<strong>primary token</strong>. Bonne nouvelleÂ pour nous, pour ce dernier prÃ©requis,
les deux types de jetons sont interchangeables grÃ¢ce Ã  la fonction
<strong>DuplicateTokenEx</strong>.</p>

<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-duplicatetokenex">https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-duplicatetokenex</a></p>

<p>Ainsi, lâ€™obtention dâ€™un <strong>impersonation token</strong> dâ€™un utilisateur (au
hasard, le compte <strong>SYSTEM</strong>) permet, grÃ¢ce Ã  <strong>DuplicateTokenEx</strong>,
dâ€™obtenir un <strong>primary token</strong> et ainsi de crÃ©er un processus dans son
contexte de sÃ©curitÃ© (et donc avec son identitÃ© et surtout ses
privilÃ¨ges ğŸ˜).</p>

<p>Câ€™est bien beau tout Ã§a, mais une question (trÃ¨sÂ ?) importante subsisteâ€¦
Comment rÃ©cupÃ©rer ce fameux <strong>access</strong> <strong>token</strong>Â ?</p>

<h1 id="parlons-bien-parlons-named-pipe"><strong>Parlons bien, parlons Â«Â Named PipeÂ Â»</strong></h1>

<p>Minute papillonÂ ! Avant de pouvoir expliquer comment rÃ©cupÃ©rer un
<strong>access token</strong>, il est nÃ©cessaire de repasser sur certaines bases
(encoreÂ ?Â ). Promis, câ€™est la derniÃ¨re foisÂ !</p>

<p>Traditionnellement, les techniques Â«Â PotatoesÂ Â» (Hot Potato, Sweet
Potato, Local Potato, etc.) utilisent des fonctions RPC pour forcer
lâ€™utilisateur <strong>NT AUTHORITY\SYSTEM</strong>Â Ã  sâ€™authentifier sur un proxy
local que lâ€™attaquant contrÃ´le, puis Ã  relayer cette authentification
jusquâ€™Ã  rÃ©cupÃ©rer un <strong>impersonation token</strong> du compte <strong>SYSTEM</strong>. Mais
lâ€™objectif de lâ€™article nâ€™est pas de revoir ces techniques bien connues
!</p>

<p>Il existe en fait un autre moyen pour aboutir au mÃªme rÃ©sultatÂ :
lâ€™utilisation de Â«Â Named PipeÂ Â».</p>

<p><img src="/assets/img/articles/coercedpotato/image6.jpg" style="width:1.76563in;height:1.10352in;display:block; margin-left:auto; margin-right:auto" alt="RenÃ© Magritte - Ceci n&#39;est pas une pipe - Museum TV" /></p>

<p>Dâ€™aprÃ¨s la documentation de Microsoft, un <em>Â«Â pipe est une section de
mÃ©moire partagÃ©e qui traite la communication entre un serveur pipe et un
client. Le processus qui crÃ©e le pipe est un <strong>serveur</strong></em> <em><strong>pipe</strong>. Un
processus qui se connecte au pipe est <strong>un client</strong>. Un processus Ã©crit
des informations dans le pipe, puis lâ€™autre processus lit les
informations du pipe. Cette vue dâ€™ensemble dÃ©crit comment crÃ©er, gÃ©rer
et utiliser des pipes.</em>Â Â»</p>

<p><a href="https://learn.microsoft.com/en-us/windows/win32/ipc/pipes">https://learn.microsoft.com/en-us/windows/win32/ipc/pipes</a></p>

<p>Pour rÃ©sumer, les <strong>pipes</strong> permettent lâ€™Ã©change de donnÃ©es
inter-processus (IPC). Sous Windows, il existe deux types de <em>pipe</em>Â :</p>

<ol>
  <li>
    <p><strong>Anonymous pipeÂ :</strong> Les â€œAnonymous pipesâ€ transfÃ¨rent les donnÃ©es
entre un processus parent et un processus enfant.</p>
  </li>
  <li>
    <p><strong>Named pipeÂ :</strong> Les â€œNamed pipesâ€ transfÃ¨rent des donnÃ©es entre des
processus qui nâ€™ont pas de lien de parentÃ©, Ã  condition quâ€™il ait
les privilÃ¨ges appropriÃ©s pour interagir avec le processus.</p>
  </li>
</ol>

<p>Dans cet article ce qui nous intÃ©resse, ce sont les <strong>named pipe</strong>.
PourquoiÂ ?</p>

<p>Parce quâ€™un processus ayant crÃ©Ã© un serveur pipe peut utiliser une
fonction trÃ¨s utile, surtout dans notre cas :
<strong>ImpersonateNamedPipeClient()</strong>. Cette fonction permet de nous placer
dans le contexte de sÃ©curitÃ© du client contactant le <strong>named pipeÂ </strong>! La
principale condition pour pouvoir lâ€™utiliser est de possÃ©der le
privilÃ¨ge <strong>SeImpersonatePrivilege</strong>â€¦ Parfait, câ€™est ce que nous allons
utiliser !Â ğŸ˜Š</p>

<p><strong><a href="https://learn.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-impersonatenamedpipeclient">https://learn.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-impersonatenamedpipeclient</a></strong></p>

<p>Cette fonction permet au serveur pipe recevant une connexion entrante
dâ€™un client (par exemple dâ€™un autre processus) dâ€™emprunter lâ€™identitÃ© du
client pour effectuer des actions en son nom, dans son contexte de
sÃ©curitÃ©, en utilisant son <strong>access token</strong>.</p>

<p>Typiquement, dans lâ€™exemple ci-dessous, nous crÃ©ons un serveur pipe
accessible via le Named Pipe <strong>\.\pipe\mynamedpipe</strong>.</p>

<p><img src="/assets/img/articles/coercedpotato/image7.png" style="width:5.72917in;height:0.31944in;display:block; margin-left:auto; margin-right:auto" /></p>

<p>Puis, lorsquâ€™un utilisateur se connecte Ã  ce serveur pipe, nous
rÃ©cupÃ©rons les informations liÃ©es Ã  son <strong>access token</strong>. Dans lâ€™exemple
ci-dessous, nous nous connectons au serveur pipe avec lâ€™utilisateur
<strong>lab\advens</strong>.</p>

<p><img src="/assets/img/articles/coercedpotato/image8.png" style="width:6.3in;height:3.51944in;display:block; margin-left:auto; margin-right:auto" /></p>

<p>Donc, pour rÃ©sumer, si nous disposons les privilÃ¨ges requis et parvenons
Ã  forcer lâ€™utilisateurÂ <strong>NT AUTHORITY\SYSTEM</strong>Â Ã  sâ€™authentifier sur un
<strong>serveur</strong> <strong>pipe</strong> que nous contrÃ´lons, nous sommes en mesure
dâ€™exÃ©cuter des processus en son nom, et donc du code (câ€™est pas beau Ã§a
?Â ğŸ˜Š).</p>

<p>ConcrÃ¨tement, câ€™est exactement ce quâ€™a expliquÃ© @Itm4n dans son blog. En
utilisant la vulnÃ©rabilitÃ© <strong>PrinterBug</strong>, lâ€™outil <strong>PrintSpoofer</strong>
permet dâ€™Ã©lever ses privilÃ¨ges et obtenir des droits <strong>NT
AUTHORITY\SYSTEM</strong> Ã  partir dâ€™un compte disposant notamment du privilÃ¨ge
<strong>SeImpersonatePrivilege</strong>.</p>

<p>Pour ne pas simplement paraphraser son article passionnant, je vous
invite Ã  le lire si vous nâ€™Ãªtes pas particuliÃ¨rement familier avec
lâ€™outil <strong>PrintSpoofer</strong>.</p>

<p><a href="https://itm4n.github.io/printspoofer-abusing-impersonate-privileges/#getting-a-system-token">https://itm4n.github.io/printspoofer-abusing-impersonate-privileges/</a></p>

<p>Le <strong>PrinterBug</strong> exploite une Â«Â fonctionnalitÃ©Â Â» implÃ©mentÃ©e dans
lâ€™interface RPC MS-RPRN en appelant la procÃ©dure RPC
<strong>RpcRemoteFindFirstPrinterChangeNotificationEx</strong>, qui permet dâ€™envoyer
une notification dâ€™impression Ã  un serveur dâ€™impression. Pour mieux
comprendre, cette fonction RPC peut Ãªtre dÃ©tournÃ©e pour forcer une
machine Ã  sâ€™authentifier oÃ¹ lâ€™on veut, simplement en indiquant un chemin
vers un (faux) serveur dâ€™impression (situÃ© sur un Named Pipe par
exemple), ce qui peut Ãªtre utile dans le cadre dâ€™autres exploits (<a href="mailto:https://medium.com/@riccardo.ancarani94/exploiting-unconstrained-delegation-a81eabbd6976">Voir
cet
article</a>).</p>

<p>NÃ©anmoins, ce qui nous intÃ©resse ici, câ€™est le bug utilisÃ© aprÃ¨s
exploitation de la vulnÃ©rabilitÃ© <strong>PrinterBug</strong>. Celui-ci rÃ©side dans un
problÃ¨me dâ€™interprÃ©tation des Â«Â /Â Â» par le systÃ¨me Windows. Je
mâ€™expliqueÂ :</p>

<p>Lorsque la procÃ©dure RPC
<strong>RpcRemoteFindFirstPrinterChangeNotificationEx</strong> est appelÃ©e, le
processus <strong>spoolsv.exe</strong>, qui est dÃ©marrÃ© dans le contexte de sÃ©curitÃ©
de lâ€™utilisateur <strong>NT AUTHORITY\SYSTEM</strong>, vÃ©rifie le chemin spÃ©cifiÃ© par
lâ€™utilisateur. Si le named pipe indiquÃ© nâ€™est pas de la forme
<strong>\somewhere\pipe\spoolss</strong>, une erreur est renvoyÃ©e, sinon, il tente
de sâ€™y connecter.</p>

<p>Par dÃ©faut, il nâ€™est pas possible de crÃ©er un named pipe dÃ©jÃ  existant,
donc pas possible dâ€™Ã©couter sur <strong>\localhost\pipe\spoolss</strong> ! En
revanche, lorsque le chemin spÃ©cifiÃ© est de la forme
<strong>\somewhere/pipe/controlled</strong>, alors le chemin spÃ©cifiÃ© est considÃ©rÃ©
comme valide (oui) et il est finalement corrigÃ© par le systÃ¨me qui
ajoute <strong>\pipe\spoolss</strong> Ã  la fin. Par consÃ©quent, une connexion est
effectuÃ©e sur <strong>\somewhere\pipe\controlled\pipe\spoolss</strong>.</p>

<p>Dans le cadre de <strong>Printspoofer</strong>, la connexion effectuÃ©e via le
processus <strong>spoolsv.exe</strong>, donc dans le contexte de sÃ©curitÃ© du compte
<strong>NT AUTHORIY\SYSTEM</strong>, se fait localement sur
<strong>\localhost\pipe\controlled\pipe\spoolss</strong>. BingoÂ ! Câ€™est un named
pipe sur lequel il est possible dâ€™Ã©couter.</p>

<p>Pour rÃ©sumer, grÃ¢ce Ã  ce bug, il est possible de rÃ©cupÃ©rer un <strong>access
token</strong> associÃ© au compte <strong>NT AUTHORITY\SYSTEM,</strong> via une connexion sur
un Named Pipe que nous contrÃ´lons. DÃ¨s lors, il est possible de dÃ©marrer
un cmd.exe avec les privilÃ¨ges <strong>SYSTEM</strong>Â !</p>

<p>Mais que se passerait-il si le spooler dâ€™impression Windows nâ€™est pas
activÃ© sur la machineÂ ?Â </p>

<p>Câ€™est lÃ  quâ€™interviennent des techniques de coercition
dâ€™authentification plus rÃ©cemment dÃ©couvertes et notre outilÂ :
<strong>CoercedPotato</strong>.</p>

<h1 id="un-peu-de-coercition-dauthentification"><strong>Un peu de Coercition dâ€™authentification</strong></h1>

<p>En 2021, la vulnÃ©rabilitÃ© PetitPotam a permis de dÃ©voiler au grand jour
la possibilitÃ© de forcer une machine Ã  sâ€™authentifier nâ€™importe oÃ¹ sur
le rÃ©seau, notamment via la fonction RPC <strong>EfsRpcOpenFileRaw</strong>
implÃ©mentÃ©e par lâ€™interface RPC <strong>MS-EFSRPC</strong>. Cette fonction permet
lâ€™ouverture dâ€™un objet chiffrÃ© sur un serveur, afin dâ€™effectuer une
sauvegarde ou de la restaurer.</p>

<p>Dans le courant de lâ€™annÃ©e 2022, le travail de P0dalirius a 
montrÃ© quâ€™il existe une multitude de fonctions RPC pouvant Ãªtre
exploitÃ©es pour forcer des authentifications grÃ¢ce Ã  son outil Coercer
(<a href="https://github.com/p0dalirius/Coercer">https://github.com/p0dalirius/Coercer</a>).</p>

<p>De plus, de nombreuses mÃ©thodes nâ€™ont pas encore Ã©tÃ© testÃ©es, mais
pourraient Ãªtre exploitÃ©es pour forcer une authentificationÂ :
<a href="https://github.com/p0dalirius/windows-coerced-authentication-methods">https://github.com/p0dalirius/windows-coerced-authentication-methods</a>.</p>

<p>Lâ€™idÃ©e nous est donc venue de la combinaison des techniques utilisÃ©es
par lâ€™outil PrintSpoofer associÃ©es aux fonctions RPC vulnÃ©rables
remontÃ©es par @P0dalirius.</p>

<p>Notre outil a ainsi pour vocation de regrouper toutes les mÃ©thodes de
coercition en local permettant une Ã©lÃ©vation de privilÃ¨ges Ã  partir des
privilÃ¨ges <strong>SeImpersonatePrivilege</strong> et <strong>SeAssignPrimaryToken</strong>.</p>

<h1 id="un-peu-de-code-maintenant-c-on-fire"><strong>Un peu de code maintenant (C++ on fire)Â !</strong></h1>

<p>En combinant les concepts expliquÃ©s prÃ©cÃ©demment, nous avons donc crÃ©Ã©
lâ€™outil CoercedPotato qui exploite le privilÃ¨ge
<strong>SeImpersonatePrivilege</strong> ou <strong>SeAssignPrimaryToken</strong> pour compromettre
une machine Windows.</p>

<p>Rentrons dans le dur maintenantÂ !Â </p>

<h2 id="ouverture-dun-serveur-pipe">Ouverture dâ€™un serveur pipe</h2>

<p>La premiÃ¨re Ã©tape consiste Ã  lancer un serveur pipe qui attend une
connexion sur un <strong>named pipe.</strong> Lâ€™objectif est de rÃ©cupÃ©rer une
connexion du compte <strong>SYSTEM</strong>, donc son <strong>access token</strong>, et dâ€™exÃ©cuter
du code en son nom.</p>

<p>Pour ce faire, dans un nouveau thread, nous lanÃ§ons les fonctions
suivantesÂ :</p>

<ol>
  <li><strong>CreateNamedPipe</strong>() â€“ CrÃ©ation dâ€™un serveur pipe en Ã©coute sur le
<strong>named pipe</strong> donnÃ© en paramÃ¨tre. En fonction des appels RPC que
nous ferons par la suite, nous Ã©coutons sur un named pipe spÃ©cifique
(par exempleÂ : <strong>\.\pipe\coerced\pipe\srvsvc</strong>).</li>
</ol>

<p><strong>CreateNamedPipe</strong>(lpName, PIPE_ACCESS_DUPLEX, PIPE_TYPE_BYTE |
PIPE_WAIT, 10, 2048, 2048, 0, &amp;sa)</p>

<ol>
  <li><strong>ConnectNamedPipe()</strong> â€“ Mise du serveur pipe en attente dâ€™une
connexion entrante. Cela permet de mettre en pause le thread.</li>
</ol>

<p><strong>ConnectNamedPipe</strong>(hPipe, NULL)</p>

<ol>
  <li><strong>ImpersonateNamedPipeClient()</strong> â€“ Une fois une connexion obtenue,
nous nous placons dans le contexte de sÃ©curitÃ© du client pour le reste du
code exÃ©cutÃ©. La connexion est contenue dans la variable <strong>hPipe</strong>.</li>
</ol>

<p><strong>ImpersonateNamedPipeClient</strong>(hPipe)</p>

<ol>
  <li><strong>OpenThreadToken()</strong> â€“ Lancement dâ€™un nouveau thread dans le contexte
de sÃ©curitÃ© du client. Cela nâ€™est possible que si la connexion au
serveur pipe a Ã©tÃ© effectuÃ©e avec un <strong>impersonation token</strong>.</li>
</ol>

<p><strong>OpenThreadToken</strong>(GetCurrentThread(), TOKEN_ALL_ACCESS, FALSE,
&amp;hToken)</p>

<ol>
  <li><strong>CreateProcessWithTokenW()</strong> â€“ Dans ce thread, nous venons dÃ©marrer un
nouveau processus (par exemple <strong>cmd.exe</strong>) Ã  lâ€™aide de
lâ€™<strong>impersonation token</strong>. Cela nâ€™est possible quâ€™avec un
<strong>impersonation token</strong> de niveau 3 ou 4.</li>
</ol>

<p><strong>CreateProcessWithTokenW</strong>(hToken, LOGON_NETCREDENTIALS_ONLY, NULL,
newCommandLine, dwCreationFlags, lpEnvironment, lpCurrentDirectory, &amp;si,
&amp;pi)</p>

<p>Et voilÃ Â ! Nous sommes maintenant capables dâ€™exÃ©cuter du code en tant
quâ€™un autre utilisateur dÃ¨s lors quâ€™il se connecte sur notre serveur
pipe.</p>

<p>Toutes ces fonctions sont documentÃ©es sur le site de Microsoft
<a href="https://learn.microsoft.com/">https://learn.microsoft.com/</a>.</p>

<p>Maintenant que tout est en place, il ne reste plus quâ€™Ã  forcer le compte
<strong>NT AUTHORITY\SYSTEM</strong> Ã  sâ€™authentifierÂ !</p>

<h2 id="crÃ©ation-du-lien-rpc">CrÃ©ation du lien RPC</h2>

<p>Selon la fonction RPC vulnÃ©rable que nous allons appeler, il peut Ãªtre
nÃ©cessaire de crÃ©er une liaison avec lâ€™interface RPC que nous voulons
utiliser : nous devons crÃ©er un <strong>RPC binding</strong> <strong>handle</strong>. Une
interface RPC pourrait sâ€™apparenter Ã  une classe en programmation
orientÃ©e objet. Elle implÃ©mente donc un certain nombre de
mÃ©thodes/fonctions. Nous commenÃ§ons par dÃ©finir la maniÃ¨re dont la
connexion RPC doit Ãªtre Ã©tablie en appelant la fonction
<strong>RpcStringBindingCompose()</strong> :</p>

<p><strong>RpcStringBindingCompose</strong>(nullptr, (RPC_WSTR)Lâ€ncalrpcâ€, nullptr,
nullptr, nullptr, &amp;bindingString);</p>

<p>Cela va permettre de crÃ©er une description de la liaison RPC qui va Ãªtre
Ã©tablie pour spÃ©cifier un certain nombre de paramÃ¨tres. Nous spÃ©cifions
dâ€™ailleurs le paramÃ¨tre <strong>sequence protocol</strong>, ici <strong>ncalrpc</strong>, qui est
un protocole permettant les connexions interprocessus. Le pointeur NULL
sur les autres paramÃ¨tres permet une liaison dynamique des interfaces
RPC auxquelles se connecter et dâ€™effectuer les connexions en local.</p>

<p>Nous lanÃ§ons ensuite la fonction <strong>RpcBindingFromStringBinding</strong> pour
effectuer la connexion RPC sur le serveur cible (localhost dans notre
cas) et rÃ©cupÃ©rer cette liaison dans la variable <strong>Binding</strong>.</p>

<p><strong>RpcBindingFromStringBinding</strong>(bindingString, &amp;binding_h)</p>

<p>Et voilÃ Â ! Nous avons maintenant Ã©tabli une connexion RPC en local.
Cette liaison RPC peut Ãªtre maintenant utilisÃ©e pour appeler des
fonctions RPC implÃ©mentÃ©es sur diffÃ©rentes interfaces.</p>

<h2 id="maintenant-que-tout-est-en-place-plus-quÃ -appeler-une-fonction-rpc-vulnÃ©rable">Maintenant que tout est en place, plus quâ€™Ã  appeler une fonction RPC vulnÃ©rable</h2>

<p>La fin de la partie technique est proche, tenez bonÂ !Â ğŸ˜Š</p>

<p>Pour faire appel Ã  une fonction RPC en C++, nous devons premiÃ¨rement
disposer dâ€™un client compilÃ© de lâ€™interface ciblÃ©e : pour lâ€™exemple,
nous prendrons <strong>MS-EFSR</strong>. Pour faire simple, pour appeler les
fonctions qui nous intÃ©ressent, il faut le code qui implÃ©mente les
fonctions RPC, notre client RPC.</p>

<p>Câ€™est lÃ  que Ã§a se compliqueâ€¦ Lâ€™objectif est donc de rÃ©cupÃ©rer un
fichier IDL (Interface Definition File) dÃ©crivant les fonctions de
lâ€™interface RPC. Ce fichier permet de compiler le code pour le client et
le serveur. Lâ€™auteur @itm4n a (heureusement) Ã©crit un article permettant
grandement dâ€™aider les personnes se lanÃ§ant dans cette quÃªteÂ :
<a href="https://itm4n.github.io/from-rpcview-to-petitpotam/">https://itm4n.github.io/from-rpcview-to-petitpotam/</a>.</p>

<p>Finalement, aprÃ¨s avoir tentÃ© plusieurs techniques compliquÃ©es et non
concluantes, il sâ€™est avÃ©rÃ© quâ€™une mÃ©thode reste la plus fiableÂ : RTFMÂ !</p>

<p>Pour chaque interface RPC, Microsoft a publiÃ© le fichier IDL dans la
documentation officielle.</p>

<p><a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-efsr/4a25b8e1-fd90-41b6-9301-62ed71334436">https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-efsr/4a25b8e1-fd90-41b6-9301-62ed71334436</a></p>

<p><img src="/assets/img/articles/coercedpotato/image9.png" style="width:6.3in;height:4.57222in;display:block; margin-left:auto; margin-right:auto" alt="Une image contenant texte, capture dâ€™Ã©cran, Police Description gÃ©nÃ©rÃ©e automatiquement" /></p>

<p>Il suffit donc de copier-coller le contenu de lâ€™IDL dans un fichier .idl
dâ€™un projet Visual Studio et de le compiler. A force de nous battre avec
les problÃ¨mes de typages,nous avons fini par trouver une solution plutÃ´t simple.
Voici notre recette :</p>

<ul>
  <li>
    <p><img src="/assets/img/articles/coercedpotato/image10.jpeg" style="width:0.18056in;height:0.19861in;display:block; margin-left:auto; margin-right:auto" alt="Une image contenant Visage humain, personne, habits, Humain Description gÃ©nÃ©rÃ©e automatiquement" />Une
fois le contenu du fichier IDL rÃ©cupÃ©rÃ© et collÃ© dans un fichier,
retirer la ligne <strong>import â€œms-dtyp.idlâ€;</strong>. Garder cette ligne
gÃ©nÃ¨re un grand nombre de problÃ¨mes de typage qui sont fastidieux Ã 
dÃ©bugger.</p>
  </li>
  <li>
    <p>Compiler lâ€™IDL pour dÃ©tecter de potentiels problÃ¨mes de dÃ©finition
de types.</p>
  </li>
</ul>

<p><img src="/assets/img/articles/coercedpotato/image11.png" style="width:4.59259in;height:1.03526in;display:block; margin-left:auto; margin-right:auto" alt="Une image contenant texte, capture dâ€™Ã©cran, Police, logiciel Description gÃ©nÃ©rÃ©e automatiquement" /></p>

<ul>
  <li>En fonction de ce qui est remontÃ©, ajouter la dÃ©finition en dÃ©but de
fichiers. La dÃ©finition de ces types se retrouve iciÂ :</li>
</ul>

<p><a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/24637f2d-238b-4d22-b44d-fe54b024280c">https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/24637f2d-238b-4d22-b44d-fe54b024280c</a></p>

<p><img src="/assets/img/articles/coercedpotato/image12.png" style="width:3.42587in;height:1.67593in;display:block; margin-left:auto; margin-right:auto" alt="Une image contenant texte, capture dâ€™Ã©cran, Police, algÃ¨bre Description gÃ©nÃ©rÃ©e automatiquement" /></p>

<ul>
  <li>Continuer ces deux derniÃ¨res Ã©tapes jusquâ€™Ã  ce que la compilation
fonctionne sans erreur.</li>
</ul>

<p>Une fois compilÃ©, le fichier IDL permet dâ€™obtenir trois fichiersÂ :
<strong>ms-efsr_c.c</strong> (le client RPC), <strong>ms-efsr_s.c</strong> (le serveur RPC) et
<strong>ms-efsr_h.h</strong> (fichier dâ€™entÃªtes). Ceux qui nous intÃ©ressent dans le
cadre de lâ€™exploit sont le fichier client RPC et le fichier dâ€™entÃªtes.
Ces fichiers implÃ©mentent donc toutes les fonctions RPC de lâ€™interface
<strong>MS-EFSR</strong> :</p>

<p><img src="/assets/img/articles/coercedpotato/image13.png" style="width:3.84466in;height:1.44062in;display:block; margin-left:auto; margin-right:auto" alt="Une image contenant texte, capture dâ€™Ã©cran, Police, affichage Description gÃ©nÃ©rÃ©e automatiquement" /></p>

<p>Il ne nous reste plus quâ€™Ã  lâ€™appeler ! Personnellement, le C et le C++,
ce nâ€™est pas ma tasse de thÃ©. Ã‡a tombe bien, bien utilisÃ©, ChatGPT est plutÃ´t
douÃ© pour Ã§aÂ !Â ğŸ˜Š</p>

<p>Nous allons donc lui demander de nous fournir le code permettant dâ€™initialiser
correctement chaque paramÃ¨tre pour chaque fonction.</p>

<p><img src="/assets/img/articles/coercedpotato/image14.png" style="width:5.76096in;height:3.65648in;display:block; margin-left:auto; margin-right:auto" alt="Une image contenant texte, Appareils Ã©lectroniques, capture dâ€™Ã©cran, logiciel Description gÃ©nÃ©rÃ©e automatiquement" /></p>

<p>Et voilÃ Â ! Toutes les fonctions sont implÃ©mentÃ©esÂ ! Il ne reste plus
quâ€™Ã  les appeler pour forcer lâ€™utilisateur <strong>NT AUTHORITY\SYSTEM</strong> Ã 
sâ€™authentifier sur notre named pipe en Ã©coute.</p>

<p>Câ€™est Ã  ce moment-lÃ  que le bug liÃ© aux Â«Â /Â Â» va faire en sorte quâ€™un
processus dÃ©marrÃ© par <strong>NT AUTHORITY\SYSTEM</strong> (dans notre cas,
<strong>lsass.exe</strong>) se connecte sur un <strong>named pipe</strong> arbitraire. Par
exemple, dans le cas de la fonction <strong>EfsRpcOpenFileRaw</strong>, nous plaÃ§ons 
notre payload dans le paramÃ¨tre <strong>FileName</strong>, qui correspond au
fichier chiffrÃ© que le serveur doit ouvrir pour rÃ©aliser ou restaurer
une sauvegarde. En lâ€™occurrence, nous lui indiquons le fichier
<strong>\127.0.0.1/pipe/coerced\C$\x00</strong>.</p>

<p>Par exemple, pour la fonction <strong>EfsRpcOpenFileRaw()</strong>, nous dÃ©finissons
le payload de la sorteÂ :</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">LPWSTR</span> <span class="n">targetedPipeName</span><span class="p">;</span>

<span class="n">targetedPipeName</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPWSTR</span><span class="p">)</span><span class="n">LocalAlloc</span><span class="p">(</span><span class="n">LPTR</span><span class="p">,</span> <span class="n">MAX</span><span class="err">\</span><span class="n">_PATH</span> <span class="err">\</span><span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="n">WCHAR</span><span class="p">));</span>

<span class="n">StringCchPrintf</span><span class="p">(</span><span class="n">targetedPipeName</span><span class="p">,</span> <span class="n">MAX</span><span class="err">\</span><span class="n">_PATH</span><span class="p">,</span>
<span class="s">L"</span><span class="se">\\\\</span><span class="s">127.0.0.1/pipe/coerced</span><span class="se">\\</span><span class="s">C$</span><span class="se">\\\x00</span><span class="s">"</span><span class="p">);</span>

<span class="kt">long</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">PVOID</span> <span class="n">pContext</span><span class="p">;</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">EfsRpcOpenFileRaw</span><span class="p">(</span><span class="n">Binding</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pContext</span><span class="p">,</span> <span class="n">targetedPipeName</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>

</code></pre></div></div>

<p>Comme expliquÃ© prÃ©cÃ©demment, Ã  cause une mauvaise interprÃ©tation du
systÃ¨me Windows, une requÃªte est effectuÃ©e sur le fichier
<a href="file:///\\127.0.0.1\pipe\coerced\pipe\srvsvc">\127.0.0.1\pipe\coerced\pipe\srvsvc</a>
par le compte <strong>NT AUTHORITY\SYSTEM</strong>.</p>

<p><img src="/assets/img/articles/coercedpotato/image15.png" style="width:5.87746in;height:0.48827in;display:block; margin-left:auto; margin-right:auto" alt="Une image contenant capture dâ€™Ã©cran, texte, logiciel, Logiciel multimÃ©dia Description gÃ©nÃ©rÃ©e automatiquement" /><img src="/assets/img/articles/coercedpotato/image15.png" style="width:5.896in;height:0.69375in;display:block; margin-left:auto; margin-right:auto" alt="Une image contenant capture dâ€™Ã©cran, texte, logiciel, Logiciel multimÃ©dia Description gÃ©nÃ©rÃ©e automatiquement" /></p>

<p>GrÃ¢ce Ã  notre serveur pipe, nous rÃ©cupÃ©rons lâ€™authentification et nous lanÃ§ons 
un nouveau processus â€œcmd.exeâ€Â !</p>

<p><img src="/assets/img/articles/coercedpotato/image16.png" style="width:6.3in;height:1.77292in;display:block; margin-left:auto; margin-right:auto" alt="Une image contenant texte, capture dâ€™Ã©cran, Police, logiciel Description gÃ©nÃ©rÃ©e automatiquement" /></p>

<p>That is all folks ğŸ˜Š. Et en prime, un petit schÃ©ma rÃ©capitulatif de
lâ€™attaqueÂ !</p>

<p><img src="/assets/img/articles/coercedpotato/image17.png" style="width:5.94589in;height:4.68903in;display:block; margin-left:auto; margin-right:auto" /></p>

<h2 id="finalement-coercedpotato">Finalement, CoercedPotatoÂ !</h2>

<p>Nous avons finalement abouti Ã  la crÃ©ation dâ€™un outil Ã©largissant ce
comportement sur lâ€™ensemble (ou presque) des fonctions RPC connues pour
Ãªtre vulnÃ©rables.</p>

<p>Ainsi, il est possible de choisir de maniÃ¨re prÃ©cise quelle fonction RPC
utiliser, ou de toutes les forcer afin dâ€™en trouver une valide.</p>

<p><img src="/assets/img/articles/coercedpotato/image18.png" style="width:6.3in;height:3.64444in;display:block; margin-left:auto; margin-right:auto" alt="Une image contenant texte, capture dâ€™Ã©cran, Police, conception Description gÃ©nÃ©rÃ©e automatiquement" /></p>

<p>A date de lâ€™article, seules les interfaces suivantes sont exploitablesÂ :</p>

<ul>
  <li>
    <p>Des fonctions implÃ©mentÃ©es sur lâ€™interface <strong>MS-RPRN</strong>Â ;</p>
  </li>
  <li>
    <p>Des fonctions implÃ©mentÃ©es sur lâ€™interface <strong>MS-EFSR</strong>.</p>
  </li>
</ul>

<p>La finalitÃ© de <strong>CoercedPotato</strong> est de parcourir lâ€™ensemble de ces
mÃ©thodes de coercition jusquâ€™Ã  en trouver une qui fonctionne.</p>

<h2 id="avancement-de-notre-recherche-petite-dÃ©sillusion">Avancement de notre rechercheÂ : petite dÃ©sillusion</h2>

<p>Comme indiquÃ© prÃ©cÃ©demment, P0dalirus a rassemblÃ© un ensemble de
fonctions RPC vulnÃ©rables pour forcer une authentification dâ€™un compte
machine sur le rÃ©seau, le tout dans lâ€™outil Coercer
(<a href="https://github.com/p0dalirius/Coercer">https://github.com/p0dalirius/Coercer</a>). Ce projet est notamment
accompagnÃ© dâ€™un autre projet qui rÃ©fÃ©rence toutes les fonctions RPC
potentiellement vulnÃ©rables, mais qui nâ€™ont pas encore Ã©tÃ© testÃ©es,
soient plus de 240 fonctionsâ€¦
(<a href="https://github.com/p0dalirius/windows-coerced-authentication-methods">https://github.com/p0dalirius/windows-coerced-authentication-methods</a>)</p>

<p>Dâ€™instinct, nous sommes partis du principe que toutes ces mÃ©thodes
seraient exploitables dans le cadre dâ€™une escalade de privilÃ¨ges en
local. Maisâ€¦ câ€™est plus compliquÃ© que Ã§a !</p>

<p>Les fonctions RPC vulnÃ©rables qui sont aujourdâ€™hui identifiÃ©es ont
toutes un point communÂ : elles prennent en entrÃ©e le chemin dâ€™un fichier
qui est censÃ© Ãªtre requÃªtÃ© par un processus lancÃ© par le compte
<strong>SYSTEM</strong>.</p>

<p>Dans le cadre de <strong>MS-RPRN</strong>, câ€™est le processus <strong>spoolsv.exe</strong> qui
effectue une requÃªte sur le named pipe. Pour <strong>MS-EFSR</strong>, câ€™est
<strong>lsass.exe</strong>.</p>

<p>Maintenant, prenons dâ€™autres interfaces qui nâ€™ont pas encore Ã©tÃ© testÃ©es,
par exemple <strong>MS-EVEN</strong>. Cette interface RPC est implÃ©mentÃ©e par le
processus <strong>svchost.exe</strong> dans le contexte de sÃ©curitÃ© de lâ€™utilisateur
<strong>NT AUTHORITY\LOCAL SERVICE</strong>, soit un compte local disposant du niveau
de privilÃ¨ges limitÃ©s.</p>

<p><img src="/assets/img/articles/coercedpotato/image19.png" style="width:4.21781in;height:2.01062in;display:block; margin-left:auto; margin-right:auto" alt="Une image contenant texte, capture dâ€™Ã©cran, affichage, nombre Description gÃ©nÃ©rÃ©e automatiquement" /></p>

<p>Par consÃ©quent, forcer ce processus Ã  effectuer une authentification sur
un named pipe que nous contrÃ´lons nâ€™a pas forcÃ©ment de sens dans notre
quÃªte dâ€™Ã©lÃ©vation de privilÃ¨ges, puisque nous rÃ©cupÃ©rons une connexion du
compte <strong>NT AUTHORITY\LOCAL SERVICE</strong>.</p>

<p><img src="/assets/img/articles/coercedpotato/image20.png" style="width:6.3in;height:2.06736in;display:block; margin-left:auto; margin-right:auto" alt="Une image contenant texte, logiciel, Police, Page web Description gÃ©nÃ©rÃ©e automatiquement" /></p>

<p><strong>Toutes les fonctions RPC des interfaces RPC implÃ©mentÃ©es par des
processus lancÃ©s dans le contexte de sÃ©curitÃ© dâ€™utilisateurs Ã  faibles
privilÃ¨ges ne sont donc pas intÃ©ressantes dans notre cas.</strong></p>

<p>Prenons ensuite le cas de <strong>MS-SRVS</strong>. Cette interface RPC est bien
implÃ©mentÃ©e par un processus lancÃ© en tant que <strong>SYSTEM</strong>. Mais ce nâ€™est
forcÃ©ment pas suffisantÂ !</p>

<p>Prenons lâ€™une de ses fonctions RPC telles que dÃ©finies dans la
documentation MicrosoftÂ : <strong>NetrFileGetInfo()</strong>.</p>

<p><img src="/assets/img/articles/coercedpotato/image21.png" style="width:6.3in;height:2.21319in;display:block; margin-left:auto; margin-right:auto" alt="Une image contenant texte, Police, capture dâ€™Ã©cran, blanc Description gÃ©nÃ©rÃ©e automatiquement" /></p>

<p>Elle prend en paramÃ¨tre 4 variablesÂ : <strong>ServerName</strong>, soit lâ€™adresse
serveur qui peut Ãªtre un named pipe, <strong>FileId</strong>, soit lâ€™ID dâ€™un fichier
(inconnu dans notre cas), <strong>Level</strong>, soit le niveau dâ€™information que
nous voulons rÃ©cupÃ©rer et <strong>InfoStruct</strong>, soit la variable qui recueille
les informations du fichier. Nous Ã©crivons ainsi le code suivant
permettant dâ€™appeler cette fonctionÂ :</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">long</span> <span class="nf">callNetrFileGetInfo</span><span class="p">(</span><span class="n">wchar</span><span class="err">\</span><span class="n">_t</span><span class="err">\</span><span class="o">*</span> <span class="n">targetedNamedPipe</span><span class="p">){</span>  
<span class="err">Â </span> <span class="err">Â </span> <span class="n">HRESULT</span> <span class="n">hr</span><span class="p">;</span>  
<span class="err">Â </span> <span class="err">Â </span> <span class="n">DWORD</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  
<span class="err">Â </span> <span class="err">Â </span> <span class="n">LPFILE</span><span class="err">\</span><span class="n">_INFO</span> <span class="n">InfoStruct</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  
<span class="err">Â </span> <span class="err">Â </span> <span class="n">DWORD</span> <span class="n">fileId</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  
<span class="err">Â </span> <span class="err">Â </span>  
<span class="err">Â </span> <span class="err">Â </span> <span class="n">RpcTryExcept</span>  
<span class="err">Â </span> <span class="err">Â </span> <span class="p">{</span>  
<span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="n">hr</span> <span class="o">=</span> <span class="n">NetrFileGetInfo</span><span class="p">(</span><span class="n">targetedNamedPipe</span><span class="p">,</span> <span class="n">fileId</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span>
<span class="n">InfoStruct</span><span class="p">);</span>  
<span class="err">Â </span> <span class="err">Â </span> <span class="p">}</span>  
<span class="err">Â </span> <span class="err">Â </span> <span class="n">RpcExcept</span><span class="p">(</span><span class="n">EXCEPTION</span><span class="err">\</span><span class="n">_EXECUTE</span><span class="err">\</span><span class="n">_HANDLER</span><span class="p">);</span>  
<span class="err">Â </span> <span class="err">Â </span> <span class="p">{</span>  
<span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="n">hr</span> <span class="o">=</span> <span class="n">RpcExceptionCode</span><span class="p">();</span>  
<span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="s">"\[-\] An error has occurred during</span><span class="err">
</span><span class="s">NetrFileGetInfo() : "</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">hr</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  
<span class="err">Â </span> <span class="err">Â </span> <span class="p">}</span>  
<span class="err">Â </span> <span class="err">Â </span> <span class="n">RpcEndExcept</span><span class="p">;</span>  
<span class="err">Â </span> <span class="err">Â </span> <span class="k">return</span> <span class="n">hr</span><span class="p">;</span>  
<span class="p">}</span>

</code></pre></div></div>

<p>Nous pourrions penser quâ€™il suffit de rÃ©pÃ©ter lâ€™exploit prÃ©cÃ©dent en
injectant notre payload dans <strong>ServerName</strong>â€¦ Mais nonÂ ! La connexion sur
le named pipe est effectuÃ©e par lâ€™utilisateur qui a lancÃ© lâ€™outil, soit
nous-mÃªmes.</p>

<p><img src="/assets/img/articles/coercedpotato/image22.png" style="width:5.94024in;height:1.84105in;display:block; margin-left:auto; margin-right:auto" alt="Une image contenant texte, logiciel, Page web, IcÃ´ne dâ€™ordinateur Description gÃ©nÃ©rÃ©e automatiquement" /></p>

<p>Exploiter cette fonction en indiquant un emplacement sur le rÃ©seau
pourrait fonctionner pour provoquer une authentification sur le rÃ©seau,
dans la mesure oÃ¹ câ€™est le compte machine qui prendrait le relai et
effectuerait la connexion. <strong>Mais en local, câ€™est un Â« auto-pwn Â» !</strong> Â â˜¹</p>

<p>Pour finir lâ€™illustration de nos propos, continuons maintenant avec la
fonction <strong>NetrpGetFileSecurity()</strong>.</p>

<p><img src="/assets/img/articles/coercedpotato/image23.png" style="width:5.63841in;height:1.86533in;display:block; margin-left:auto; margin-right:auto" alt="Une image contenant texte, capture dâ€™Ã©cran, Police, blanc Description gÃ©nÃ©rÃ©e automatiquement" /></p>

<p>Le code suivant a Ã©tÃ© utilisÃ©Â :</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// shareName doit correspondre Ã  un partage rÃ©seau valide.</span>

<span class="kt">long</span> <span class="nf">callNetrpGetFileSecurity</span><span class="p">(</span><span class="n">wchar</span><span class="err">\</span><span class="n">_t</span><span class="err">\</span><span class="o">*</span> <span class="n">shareName</span><span class="p">)</span> <span class="p">{</span>  
<span class="err">Â </span> <span class="err">Â </span> <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
  
<span class="err">Â </span> <span class="err">Â </span> <span class="n">wchar</span><span class="err">\</span><span class="n">_t</span><span class="err">\</span><span class="o">*</span> <span class="n">serverName</span><span class="p">;</span>  
<span class="err">Â </span> <span class="err">Â </span> <span class="n">serverName</span> <span class="o">=</span> <span class="p">(</span><span class="n">wchar</span><span class="err">\</span><span class="n">_t</span><span class="err">\</span><span class="o">*</span><span class="p">)</span><span class="n">LocalAlloc</span><span class="p">(</span><span class="n">LPTR</span><span class="p">,</span> <span class="n">MAX</span><span class="err">\</span><span class="n">_PATH</span> <span class="err">\</span><span class="o">*</span>
<span class="k">sizeof</span><span class="p">(</span><span class="n">WCHAR</span><span class="p">));</span>  
<span class="err">Â </span> <span class="err">Â </span> <span class="n">StringCchPrintf</span><span class="p">(</span><span class="n">serverName</span><span class="p">,</span> <span class="n">MAX</span><span class="err">\</span><span class="n">_PATH</span><span class="p">,</span> <span class="s">L"localhost"</span><span class="p">);</span>  
  
<span class="err">Â </span> <span class="err">Â </span> <span class="n">wchar</span><span class="err">\</span><span class="n">_t</span><span class="err">\</span><span class="o">*</span> <span class="n">lpFileName</span><span class="p">;</span>  
<span class="err">Â </span> <span class="err">Â </span> <span class="n">lpFileName</span> <span class="o">=</span> <span class="p">(</span><span class="n">wchar</span><span class="err">\</span><span class="n">_t</span><span class="err">\</span><span class="o">*</span><span class="p">)</span><span class="n">LocalAlloc</span><span class="p">(</span><span class="n">LPTR</span><span class="p">,</span> <span class="n">MAX</span><span class="err">\</span><span class="n">_PATH</span> <span class="err">\</span><span class="o">*</span>
<span class="k">sizeof</span><span class="p">(</span><span class="n">WCHAR</span><span class="p">));</span>  
<span class="err">Â </span> <span class="err">Â </span> <span class="n">StringCchPrintf</span><span class="p">(</span><span class="n">lpFileName</span><span class="p">,</span> <span class="n">MAX</span><span class="err">\</span><span class="n">_PATH</span><span class="p">,</span> <span class="s">L"foo1234"</span><span class="p">);</span>  
  
<span class="err">Â </span> <span class="err">Â </span> <span class="n">SECURITY</span><span class="err">\</span><span class="n">_INFORMATION</span> <span class="n">RequestedInformation</span> <span class="o">=</span>
<span class="n">OWNER</span><span class="err">\</span><span class="n">_SECURITY</span><span class="err">\</span><span class="n">_INFORMATION</span> <span class="o">|</span> <span class="n">GROUP</span><span class="err">\</span><span class="n">_SECURITY</span><span class="err">\</span><span class="n">_INFORMATION</span> <span class="o">|</span>
<span class="n">DACL</span><span class="err">\</span><span class="n">_SECURITY</span><span class="err">\</span><span class="n">_INFORMATION</span><span class="p">;</span>  
<span class="err">Â </span> <span class="err">Â </span> <span class="n">PADT</span><span class="err">\</span><span class="n">_SECURITY</span><span class="err">\</span><span class="n">_DESCRIPTOR</span> <span class="n">SecurityDescriptor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  
  
  
<span class="err">Â </span> <span class="err">Â </span> <span class="n">result</span> <span class="o">=</span> <span class="n">NetrpGetFileSecurity</span><span class="p">(</span><span class="n">serverName</span><span class="p">,</span> <span class="n">shareName</span><span class="p">,</span> <span class="n">lpFileName</span><span class="p">,</span>
<span class="n">RequestedInformation</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">SecurityDescriptor</span><span class="p">);</span>  
<span class="err">Â </span> <span class="err">Â </span> <span class="n">wprintf</span><span class="p">(</span><span class="s">L"NetrpGetFileSecurity returned %lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>  
<span class="err">Â </span> <span class="err">Â </span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>  
<span class="p">}</span>

</code></pre></div></div>

<p>Pour utiliser cette fonction, il est nÃ©cessaire dâ€™utiliser un partage
rÃ©seau valide. Une erreur est renvoyÃ©e le cas contraire. Une fois cette
condition remplie, il est effectivement possible de forcer lâ€™exÃ©cution
dâ€™une requÃªte par lâ€™utilisateur <strong>NT AUTHORITY\SYSTEM</strong>. Petit bÃ©molÂ :
le chemin indiquÃ© correspond Ã  un chemin de fichier absoluâ€¦</p>

<p><img src="/assets/img/articles/coercedpotato/image24.png" style="width:5.86999in;height:1.76867in;display:block; margin-left:auto; margin-right:auto" alt="Une image contenant texte, logiciel, Page web, IcÃ´ne dâ€™ordinateur Description gÃ©nÃ©rÃ©e automatiquement" /></p>

<p>Cette fonction ne peut donc pas Ãªtre utilisÃ©e pour Ã©lever nos privilÃ¨ges
en local.</p>

<p>Pour rÃ©sumer, la recherche de fonctions vulnÃ©rables pour une Ã©lÃ©vation
de privilÃ¨ges en local requiert finalement plus de prÃ©requis que prÃ©vu.
Certaines interfaces RPC sont exploitables pour de la coercition
dâ€™authentification sur le rÃ©seau, mais pas en local. Pour autant, nous
continuons de chercher de nouvelles mÃ©thodes vulnÃ©rablesÂ !Â </p>

<p>En revanche, les fonctions actuellement implÃ©mentÃ©es dans notre outil
nâ€™ont pas Ã©tÃ© patchÃ©es et ne seront certainement pas patchÃ©es, dans la
mesure oÃ¹ leurs comportements sont considÃ©rÃ©s comme Â«Â lÃ©gitimes Â» par
Microsoft.</p>

<p>Vous retrouvez le code de lâ€™outil iciÂ :
<a href="https://github.com/hackvens/CoercedPotato"><span>https://github.com/hackvens/CoercedPotato</span></a>.</p>

<p>Notre PoC a Ã©tÃ© testÃ© sur Windows 10, Windows Server 2016, Windows
Server 2022 et Windows 11 ! ğŸ¥³</p>

<p>Et voilÃ , vous savez tout Ã  propos de CoercedPotatoÂ !</p>

<h1 id="remerciements"><strong>Remerciements</strong></h1>

<p>Nous souhaiterions remercier toutes celles et ceux qui nous ont apportÃ©
leurs aides durant nos recherches et plus particuliÃ¨rement :</p>

<ul>
  <li>
    <p><strong>RÃ©mi GASCOU</strong> (@Podalirius) pour ses travaux sur lâ€™utilisation
dâ€™appels RPC et la crÃ©ation de lâ€™outil Coercer.</p>
  </li>
  <li>
    <p><strong>ClÃ©ment LABRO</strong> (@itm4n) pour ses articles et recherches sur
Printspoofer et Petitpotam.</p>
  </li>
  <li>
    <p><strong>Guillaume DAUMAS</strong> (@BlackWasp) pour ses relectures et conseils.</p>
  </li>
  <li>
    <p><strong>Advens</strong> pour lâ€™organisation de la Hackvens ainsi que le temps
allouÃ© Ã  nos recherches.</p>
  </li>
</ul>

<p>ğŸ¥”</p>

<p>Un article de <em>RaphaÃ«l HUON et ThÃ©o BERTRAND</em></p>


    </div>
</div>


    </div>
  </body>
</html>
